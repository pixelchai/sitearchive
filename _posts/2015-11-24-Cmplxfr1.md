---
layout: posti
title: CodeComplexifier - Complex Booleans
date:   2015-11-24 6:42:45
subclat: 'CodeComplexifier'
categories: 'cm'
image:
  feature: PZ/booltree.png
  credit: David Eppstein
  creditlink: https://commons.wikimedia.org/wiki/User:David_Eppstein/Gallery
---

A new project that I am stating alongside my <a href="{{ site.baseUrl }}/tag/UniversalProgram">Universal Program</a> project!
This project is going to, essentially, be a code complexifier. Probably wouldn't exactly be obfuscation, but it will generate code that will most likely be unreadable to the untrained eye.

This program rewrites your code, but using the most complex and ineficient ways of doing things. I don't really see why anyone will need this, but it is cool nonetheless.

Okay, let's get started by making the conditions unnecessarily complex!

<h3><u>Booleans</u></h3>
Whenever you do a condition, the condition always has to be a boolean.
In while loops, if statements, etc.
Say, for example, you have a condition `no != 10`. You might be using it in a while loop, for example:
{% highlight csharp %}
int no = 0;
while(no != 10)
{
	no++;
}
{% endhighlight %}

Since the condition is a boolean, you can easily add `== true` to the end without it affecting the code. After all, the condition is just the short-hand way of writing that.
{% highlight csharp %}
int no = 0;
while(no != 10 == true)
{
	no++;
}
{% endhighlight %}

Now, there are many ways we could say `true`. If we felt particularly groovy that day, we could write `no != 10 == !false` because !false = true.

Heck, we could even write `no != 10 != !!false`
Or this: `no != 10 != !!false != !false != true`

This is because `!false`,`!= !!false != !false != true`,`!= !!false` are all ways of saying `true`.
Now let's make a method that replaces every instance of `true` in the statement with one of these more complex ways of expressing `true`.
Like I mentioned earlier, we can always add `== true` to any condition without making a difference. Even if the condition already has `== true` at the end:

`true == true == true` = `true == true` = `true`.

So you don't need to worry about a condition without an instance of `true` in it, we can just add one right at the start.

Ok, great, our method has made the condition slightly more complex. Now how about putting _that_ condition through the algorithm again. It will be even more complex!

Since my method replaces EVERY instance of `true` found with a random way of expressing `true`, the complexity will actually increase exponentially.

Here's the method:
{% highlight csharp %}public string complexifyCondition(string cond, int times)
        {
            Console.Write("complexifying...");
            string[] trues = new string[] { "!true == !true", "true != !true"+Environment.NewLine, "!!!true != !!true", "!false != !true"+Environment.NewLine, "!!false != true != !false == !true"
            ,"!!!false == !!true"};
            string ret = cond+" == true";
            int no = times;
            while (no != 0)
            {
                var regex = new Regex(Regex.Escape("true"));
                int na = Regex.Matches(ret, "true").Count;
                while (na != 0)
                {
                    var newText = regex.Replace(ret, trues[r.Next(trues.Length)], 1);
                    ret = newText;
                    na--;
                    // Console.Write(".");
                }
                //Console.ForegroundColor = ConsoleColor.Red;
                //Console.Write(".");
                //Console.ResetColor();
                no--;
            }
            System.Windows.Forms.Clipboard.SetText(ret);
            return ret;
        }{% endhighlight %}

Let's give it a spin!
Let's input our example condition `no != 10`:
<table><tbody>
<tr><th>Times</th><th>Output</th></tr>
<tr><td>0</td><td>no != 10 == true</td></tr>
<tr><td>1</td><td>no != 10 == !!!true != !!true</td></tr>
<tr><td>2</td><td>no != 10 == !false != !!!!false == !!true</td></tr>
<tr><td>3</td><td>no != 10 == !!!!!false != !!!false == !!!!false != !!!false == !!!!false != true != !false == !true != !false == !true
!= !false == !true != !!true</td></tr>
<tr><td>4</td><td>no != 10 == !!false != !!!false != !false != !!!!false == !!!!!!!!false == !!!!!false == !!!!false != true != !false == !true != !!true != !true!= !true!= !false == !true== !true</td></tr>
</tbody>
</table>
etc...
<a href="http://pastebin.com/zrQj6KBu">Here</a> is the output when the complexity is set to 19.
I probably won't be able to run it on my secondary computer (because it is slow), but, theoretically if you replace `no != 10` at the start with `bool b =`,
the value of the boolean should be `True`!

See, this is why 
>Oh i've written 5000 lines of code broo!

means very little to me. To all those who have ever said that, I say: 

>Oh i've written 7,264 lines of code in like 10 seconds broo!

7,264 lines of code for only a simple boolean "true". How's that for complex booleans?
And the complexity was only set to 19... 

I wouldn't recommend going above 10, however. Your computer might have a hard time generating the condition. When I pasted that code into Visual Studio, it insta-crashed on this pc __x_x__

<h3><u>What my initial intentions were</u></h3>
I initially intended to make an algorithm that would do the following:
{% highlight csharp %}
int no = 0;
while(no != 10)
{
	no++;
}
{% endhighlight %}
---
Converted to:
{% highlight csharp %}
private int Do(int no){
return no+=1;
}
private bool Check(int no){
return no != 10;
}
int no = 0;
:foo
no = Do(no);
if(!Check(no)){
goto foo;
}
{% endhighlight %}

Notice how the code is now suddenly more complex. Making that code is quite complex, though, because you will need to work out which variables to pass etc etc. I somehow started experimenting with bools and now this happened.
I also made a method to actually parse the condition from a loop/statement:
{% highlight csharp %}public string GetBoolfloop(string lname, params string[]raw)
        {
            foreach (var loc in raw)
            {
                if (loc.Contains(lname))
                {
                    //Console.WriteLine("located loop def :" + loc);
                    string only = loc.Substring(loc.IndexOf(lname));
                   // Console.WriteLine("isolated: "+only);
                    string boolarg = "";
                    bool started = false;
                    foreach (var s in only)
                    {
                        if (s == ')') started = false;
                        if (started)
                        {
                            boolarg += s;
                        }
                        if (s == '(') started = true;
                    }
                 //   Console.WriteLine("isolated boolarg: " + boolarg);
                    return boolarg;
                }
            }
            return "";
        }{% endhighlight %}
And a method to get the code within the loop/statement:
{% highlight csharp %}
public string GetCodefbrackets(string sbracket,string ebracket, params string[] code)
        {
            string ret = "";
            bool started = false;
            foreach (var loc in code)
            {
                if (loc.Contains(ebracket))
                {
                    started = false;
                    ret += Environment.NewLine+loc.Replace(ebracket, "");
                    continue;
                }
                if (started)
                {
                    ret += Environment.NewLine + loc;
                }
                if (loc.Contains(sbracket))
                {
                    started = true;
                    ret += loc.Substring(loc.IndexOf(sbracket)+1);
                 //   Console.WriteLine(ret);
                }
            }
            //Console.WriteLine(ret);
            return ret;
        }
{% endhighlight %}

---
<!-- footer -->

Time taken to write: An hour and a bit

---